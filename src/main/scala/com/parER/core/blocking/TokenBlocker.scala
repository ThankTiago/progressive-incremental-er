package com.parER.core.blocking

import com.parER.datastructure.InvertedIndex
import org.scify.jedai.textmodels.TokenNGrams

import scala.collection.mutable

class TokenBlocker extends Blocking {

  val invertedIndex = new InvertedIndex
  val rankMap = new mutable.HashMap[String, Float]()
  val sizeMap = new mutable.HashMap[String, Int]()
  val blockMap = new mutable.HashMap[String, Float]()

  protected var modelStoring = true

  override def setModelStoring(value: Boolean) = {
    modelStoring = value
    println("Model storing? " + modelStoring)
  }

  // Here you return the total number of comparisons generated by the textModel
  override def execute(idx: Int, textModel: TokenNGrams) = {
    import scala.jdk.CollectionConverters._
    val textModelTokens = textModel.getSignatures.asScala.toList
    execute(idx, textModel, textModelTokens)
  }

  override def execute(idx: Int, textModel: TokenNGrams, keys: List[String]) = {

    // generate comparisons in the form e1, e2 with e1 < e2 => e2 current idx
    val comparisons = invertedIndex.generate(idx, textModel, keys, modelStoring)   // TODO make packages of fixed size

    // update indexes
    invertedIndex.update(idx, textModel, keys, modelStoring)

    comparisons
  }

  override def progressiveProcess(idx: Int, textModel: TokenNGrams) = {
    import scala.jdk.CollectionConverters._
    val textModelTokens = textModel.getSignatures.asScala.toList
    progressiveProcess(idx, textModel, textModelTokens)
  }

  // THIS METHOD SUPPORTS ONLY THE SCENARIO WHERE MODELSTORING IS FALSE
  override def progressiveProcess(idx: Int, textModel: TokenNGrams, keys: List[String]) = {
    val dId = textModel.getDatasetId
    // get blocks and apply block cutting and first step of block filtering
    val associatedBlocks = invertedIndex.getBlocks(idx, dId, keys)
    // build tuple and update inverted index data structure
    val blocks = (associatedBlocks map {case (k,v) => (k,v.toList)} ).toList
    //val blocks = associatedBlocks.values.map(_.toList).toList
    val tuple = (idx, textModel, blocks)
    invertedIndex.update(idx, textModel, associatedBlocks.keys.toList, modelStoring)
    tuple
  }

  override def process(idx: Int, textModel: TokenNGrams) = {
    import scala.jdk.CollectionConverters._
    val textModelTokens = textModel.getSignatures.asScala.toList
    process(idx, textModel, textModelTokens)
  }

  // THIS METHOD SUPPORTS ONLY THE SCENARIO WHERE MODELSTORING IS FALSE
  override def process(idx: Int, textModel: TokenNGrams, keys: List[String]) = {
    val dId = textModel.getDatasetId
    // get blocks and apply block cutting and first step of block filtering
    val associatedBlocks = invertedIndex.getBlocks(idx, dId, keys)
    // build tuple and update inverted index data structure
    val blocks = associatedBlocks.values.map(_.toList).toList
    val tuple = (idx, textModel, blocks)
    invertedIndex.update(idx, textModel, associatedBlocks.keys.toList, modelStoring)
    tuple
  }

  def getBlock(id: Int, dId: Int, key: String) = {
    invertedIndex.getBlock(id, dId, key).toList
  }

  def getBlock(dId: Int, key: String) = {
    invertedIndex.getBlock(dId, key).toList
  }

  def getBlockSizes = invertedIndex.getBlockSizes()

  def progressiveUpdate(key: String, rank: Float, size: Int) = {
    val oldRank = rankMap.getOrElseUpdate(key, 0.0f)
    rankMap(key) = oldRank+rank

    val oldSize = sizeMap.getOrElseUpdate(key, 0)
    sizeMap(key) = oldSize+size

    blockMap(key) = rankMap(key) / math.max ( 1.0f,  sizeMap(key).toFloat )
  }

  def progressiveGetMax() = {
    blockMap.maxBy(_._2)
  }

  def progressiveReset(key: String) = {
    rankMap(key) = 0.0f
    sizeMap(key) = 0
  }

  override def countComparisons(): Int = invertedIndex.countComparisons()
}
